/*
 * This source file was generated by the Gradle 'init' task
 */
package com.kimikevin;

import com.kimikevin.generics.GenericType;
import com.kimikevin.generics.ImmutableArray;
import com.kimikevin.generics.NonGenericClass;

import java.util.EnumSet;

public class App {

    public static void main(String[] args) {
        // throwing a runtime exception(Throwable)
//        RuntimeException exception = new RuntimeException("Something went wrong");
//        throw exception;
        // throwing a checked exception
//        try {
//            System.out.println(readTextFromFile("path_to_file"));
//        } catch (IOException e) {
//            System.out.println(e.getMessage());
//        }

//        // throwing unchecked exceptions
//        Account account = new Account();
//        account.deposit(100);
//        System.out.println(account.getBalance());

//        // example of throwing unchecked exceptions
//        Scanner scanner = new Scanner(System.in);
//        int dayNumber = scanner.nextInt();
//        try {
//            System.out.println(getDayOfWeekName(dayNumber));
//        } catch (Exception e) {
//            System.out.println(e.getClass().getName());
//        }

//        // local date
//        LocalDate now = LocalDate.now();
//        LocalDate date1 = LocalDate.of(2025, 10, 22); // 2025-10-22 (22 October 2025)
//        LocalDate date2 = LocalDate.parse("2025-10-22"); // 2025-10-22 (22 October 2025)
//
//        System.out.println(now);
//        System.out.println(date1);
//        System.out.println(date2);
//
//        System.out.println(LocalDate.ofYearDay(2016, 365)); // 2016-12-30 (30 December 2016)
//        System.out.println(LocalDate.ofYearDay(2017, 365)); // 2017-12-31 (31 December 2017)
//
//        System.out.println(LocalDate.ofYearDay(2017, 366)); // here an exception occurs, because the year is not a leap year
//
//        LocalDate date = getLocalDate();
//        LocalDate in2016 = date.withYear(2016);   // 2016-01-01 (1 January 2016)

//        // 2 weeks after
//        Scanner scanner = new Scanner(System.in);
//        String date = scanner.nextLine();
//
//        LocalDate localDate = LocalDate.parse(date);
//        System.out.println(localDate.plusWeeks(2));

//        // find all mondays
//        Scanner scanner = new Scanner(System.in);
//        int year = scanner.nextInt();
//        int month = scanner.nextInt();
//
//        List<LocalDate> mondays = getMondays(year, month);
//        for (LocalDate monday: mondays) {
//            System.out.println(monday);
//        }

//        // Print dates of a year with an offset
//        Scanner scanner = new Scanner(System.in);
//        String date = scanner.nextLine();
//        int offset = scanner.nextInt();
//
//        LocalDate localDate = LocalDate.parse(date);
//
//        LocalDate endOfYear = localDate.withDayOfYear(localDate.lengthOfYear());
//
//        for (int i = localDate.getDayOfYear(); !localDate.isAfter(endOfYear) ; i += offset ) {
//            System.out.println(localDate);
//            localDate = localDate.plusDays(offset);
//        }

//        // 30 years before and after
//        Scanner scanner = new Scanner(System.in);
//        String date  = scanner.nextLine();
//
//        LocalDate localDate = LocalDate.parse(date);
//
//        System.out.println(localDate.minusYears(30));
//        System.out.println(localDate.plusYears(30));

//        // Convert numbers to days
//        Scanner scanner = new Scanner(System.in);
//        int year = scanner.nextInt();
//        int day1 = scanner.nextInt();
//        int day2 = scanner.nextInt();
//        int day3 = scanner.nextInt();
//
//        LocalDate date1 = LocalDate.ofYearDay(year, day1);
//        LocalDate date2 = LocalDate.ofYearDay(year, day2);
//        LocalDate date3 = LocalDate.ofYearDay(year, day3);
//
//        LocalDate[] dates = new LocalDate[]{date1, date2, date3};
//        for (LocalDate date: dates) {
//            System.out.println(date);
//        }

//        // The first and the last day of a month
//        Scanner scanner = new Scanner(System.in);
//        int year = scanner.nextInt();
//        int month = scanner.nextInt();
//
//        LocalDate firstDay = LocalDate.of(year, month, 1);
//        LocalDate lastDay = LocalDate.of(year, month, firstDay.lengthOfMonth());
//
//        System.out.println(firstDay + " " + lastDay);

//        // 10 days before
//        Scanner scanner = new Scanner(System.in);
//        String day = scanner.nextLine();
//
//        LocalDate date = LocalDate.parse(day);
//
//        System.out.println(date.minusDays(10));

//        // Leap Year Check: A Date's True Colors
//        Scanner scanner = new Scanner(System.in);
//        String day = scanner.nextLine();
//
//        LocalDate localDate = LocalDate.parse(day);
//
//        System.out.println(localDate.isLeapYear());

//        // accessing with the name() method
//        UserStatus active = UserStatus.ACTIVE;
//        System.out.println(active.name());
//
//        // accessing by it\'s name with the valueOf() method
//        UserStatus blocked = UserStatus.valueOf("BLOCKED");
//        System.out.println(blocked.name());
//
//        // accessing all the values
//        UserStatus[] statuses = UserStatus.values();
//        System.out.println(Arrays.toString(statuses));
//
//        // accessing the position using the ordinal() method
//        System.out.println(active.ordinal());
//        System.out.println(blocked.ordinal());
//        System.out.println(UserStatus.PENDING.ordinal());
//
//        // using the equals() method and the '==' operator
//        System.out.println(active.equals(UserStatus.ACTIVE));
//        System.out.println(active == UserStatus.ACTIVE);
//
//        // using enums in switch statements
//        UserStatus test = UserStatus.PENDING;
//
//        switch (test) {
//            case PENDING -> {
//                System.out.println("You need to wait a little.");
//                break;
//            }
//            case ACTIVE -> {
//                System.out.println("No problems, you may pass here.");
//                break;
//            }
//            case BLOCKED -> {
//                System.out.println("Stop! You can't pass here.");
//                break;
//            }
//            default -> System.out.println("Unsupported enum constant.");
//        }
//
//        // iterating over an enum
//        for (UserStatus status : UserStatus.values()) {
//            System.out.println(status.name().startsWith("BLOCKED"));
//        }

//        int tasteValue = 0;
//        ThingsToTaste taste = ThingsToTaste.values()[tasteValue];
//
//        tasteValue = switch (taste) {
//            case SUGAR, PIZZA, CHOCOLATE -> 10;
//            case MEATBALLS, STEAK -> 7;
//            case BROCCOLI -> 4;
//            case DIRT -> 1;
//            default -> throw new IllegalStateException("Invalid tastable object: " + taste);
//        };
//
//        System.out.println(taste + ": " + tasteValue);

//        // macOS style
//        File file = new File("/Users/kimi-kevin/Documents"); // a directory on a UNIX-like system
//        System.out.println("file: " + file.getAbsolutePath());
//
//        // character for separating the path to a file
//        System.out.println(File.separator);
//
//        System.out.println("File name: " + file.getName());
//        System.out.println("File path: " + file.getPath());
//        System.out.println("Is file: " + file.isFile());
//        System.out.println("Is directory: " + file.isDirectory());
//        System.out.println("Exists: " + file.exists());
//        System.out.println("Parent path: " + file.getParent());

//        // files
//        File file = new File("/Users/kimi-kevin/Documents/Example.txt");
//        if (file.exists()) {
//            System.out.println(file.getName() + " exists");
//            file.delete();
//        } else {
//            System.out.println("File not found");
//        }

//        // Reading data using Scanner
//        String pathToFile = "/Users/kimi-kevin/Documents/readme.txt";
//        File file = new File(pathToFile);
//
//        try(Scanner scanner = new Scanner(file)) {
//
//            while (scanner.hasNext()) {
//                System.out.print(scanner.nextLine() + "\n");
//            }
//        } catch (FileNotFoundException exception) {
//            System.out.println("File not found: " + exception.getMessage());
//        }
//        // Reading all text from a file as a single string
//        try {
//            System.out.println(readFileAsString(pathToFile));
//        } catch (IOException e) {
//            System.out.println("Cannot read file: " + e.getMessage());
//        }

//        String pathToFile = "/Users/kimi-kevin/Documents/file.txt";
//        try (Scanner scanner = new Scanner (new File(pathToFile))) {
//            scanner.nextLine();
//            scanner.nextLine();
//            System.out.println(scanner.nextLine());
//        } catch (FileNotFoundException e) {
//            System.out.println(e.getMessage());
//        }

//        // The sum of numbers in a file
//        String pathToFile = "/Users/kimi-kevin/Desktop/github/oracle-java-foundations/demo/app/src/main/resources/dataset.txt";
//
//
//        try{
//           Scanner scanner = new Scanner(new File(pathToFile));
//            scanner.useDelimiter("[,\\s]+");
//           int sum = 0;
//           while (scanner.hasNext()) {
//               int num = Integer.parseInt(scanner.nextLine());
//               sum += num;
//           }
//            System.out.println(sum);
//
//           scanner.close();
//        } catch (FileNotFoundException e) {
//            System.out.println("File not found" + e.getMessage());
//        }

//        // Find the greatest number in a file
//        String pathToFile = "/Users/kimi-kevin/Desktop/github/oracle-java-foundations/demo/app/src/main/resources/dataset.txt";
//
//        try {
//            Scanner scanner = new Scanner(new File(pathToFile));
//            scanner.useDelimiter("[,\\s]+");
//
//            ArrayList<Integer> list = new ArrayList<>();
//
//            while (scanner.hasNextInt()) {
//                list.add(scanner.nextInt());
//            }
//
//            int[] numbers = list.stream().mapToInt(Integer::intValue).toArray();
//
//            System.out.println(findFirstIndexOfMax(numbers));
//        } catch (FileNotFoundException e) {
//            System.out.println("File not found " + e.getMessage());
//        }

//        // World population
//        String pathToFile = "/Users/kimi-kevin/Desktop/github/oracle-java-foundations/demo/app/src/main/resources/dataset.txt";
//        String year = "";
//        long diffMax = 0;
//        long temp = 0;
//        File file = new File(pathToFile);
//
//
//        try (Scanner scanner = new Scanner(file)){
//            StringBuilder input = new StringBuilder();
//            while (scanner.hasNext()){
//                input.append(scanner.next().replace(",", "")).append(" ");
//            }
//            String[] inputArray = input.toString().split(" ");
//
//            for(int i = 5; i < inputArray.length; i += 2){
//                temp = Long.parseLong(inputArray[i]) - Long.parseLong(inputArray[i-2]);
//                if (temp > diffMax){
//                    diffMax = temp;
//                    year = inputArray[i-1];
//                }
//            }
//        } catch (FileNotFoundException e){
//            System.out.println(e.getMessage());
//        }
//        System.out.println("Maximum growth in: " + year);

//        String pathToFile = "/Users/kimi-kevin/Desktop/github/oracle-java-foundations/demo/app/src/main/java/com/kimikevin/file.txt";
//        try (Scanner scanner = new Scanner(new File(pathToFile))) {
//            System.out.println(scanner.nextInt());
//        } catch (FileNotFoundException e) {
//            System.out.println(e.getMessage());
//        }

//        // even counter
//        String pathToFile = "/Users/kimi-kevin/Desktop/github/oracle-java-foundations/demo/app/src/main/resources/dataset.txt";
//        int evenCounter = 0;
//        File file = new File(pathToFile);
//
//        try (Scanner scanner = new Scanner(file)){
//            int temp = scanner.nextInt();
//            while (scanner.hasNext() && temp != 0){
//                evenCounter += temp % 2 == 0 ? 1 : 0;
//                temp = scanner.nextInt();
//            }
//        } catch (FileNotFoundException e){
//            System.out.println(e.getMessage());
//        }
//        System.out.println(evenCounter);

//        // creating files
//        File file = new File("/Users/kimi-kevin/Documents/file.txt");
//        try {
//            boolean createdNew = file.createNewFile();
//            if (createdNew) {
//                System.out.println("The file was successfully created.");
//            } else {
//                System.out.println("The file already exists.");
//            }
//        } catch (IOException e) {
//            System.out.println("Cannot create the file: " + file.getPath());
//        }

//        // creating directory
//        File file = new File("/Users/kimi-kevin/Documents/dir");
//
//        boolean createdNewDirectory = file.mkdir();
//        if (createdNewDirectory) {
//            System.out.println("It was successfully created.");
//        } else {
//            System.out.println("It was not created.");
//        }
//
//        // creating directories
//        File directory = new File("/Users/kimi-kevin/Documents/dir/dir/dir");
//
//        boolean createdNewDirectories = directory.mkdirs();
//        if (createdNewDirectories) {
//            System.out.println("It was successfully created.");
//        }  else {
//            System.out.println("It was not created.");
//        }

//        // removing files and directories
//        File directory = new File("/Users/kimi-kevin/Documents/dir/dir/dir");
//
//        if (directory.delete()) {
//            System.out.println("It was successfully removed.");
//        } else {
//            System.out.println("It was not removed.");
//        }

//        // removing subdirectories and subfiles
//        File directory = new File("/Users/kimi-kevin/Documents/dir/dir");
//        deleteDirRecursively(directory);

//        // renaming files
//        File file = new File("/Users/kimi-kevin/Documents/file.txt");
//        File renamedFile = new File("/Users/kimi-kevin/Documents/refill.txt");
//
//        boolean renamed = file.renameTo(renamedFile);
//        if (renamed) {
//            System.out.println("It was successfully renamed.");
//        } else {
//            System.out.println("It was not renamed.");
//        }

//        // moving files
//        File file = new File("/Users/kimi-kevin/Documents/refill.txt");
//        File renamedFile = new File("/Users/kimi-kevin/Documents/dir/refill.txt");
//
//        boolean renamed = file.renameTo(renamedFile);
//        if (renamed) {
//            System.out.println("It was successfully moved.");
//        } else {
//            System.out.println("It was not moved.");
//        }


//        // fields and methods in enum
//        System.out.println(ChargeLevel.LOW.getSections()); // 1
//        System.out.println(ChargeLevel.LOW.getColor()); // red
//        System.out.println(ChargeLevel.findByNumberOfSections(2)); // MEDIUM

//        for (Planet planet : Planet.values()) {
//            if (planet.mass() > 5.0e+24 && planet.radius() > 6.0e+7) {
//                System.out.println(planet);
//            }
//        }

//        LocalTime now = LocalTime.now();
//        System.out.println(now);
//
//        // using the of() and parse() methods
//        System.out.println(LocalTime.of(11, 45));        // 11:45
//        System.out.println(LocalTime.of(11, 45, 30));    // 11:45:30
//        System.out.println(LocalTime.parse("11:45:30")); // 11:45:30 (hours, minutes, seconds)
//
//        // using the ofSecondOfDay() and ofNanoOfDay() methods
//        LocalTime secondTime = LocalTime.ofSecondOfDay(12345);
//        LocalTime nanotime = LocalTime.ofNanoOfDay(1234567890);
//        System.out.println(secondTime);
//        System.out.println(nanotime);
//
//        // some predefined constants
//        LocalTime min = LocalTime.MIN;// 00:00
//        LocalTime max = LocalTime.MAX;// 23:59:59.999999999
//        LocalTime noon = LocalTime.NOON;// 12:00
//        LocalTime midnight = LocalTime.MIDNIGHT;// 00:00
//
//        // getting hours, minutes, seconds and nanoseconds
//        LocalTime time = LocalTime.of(11, 45, 30);
//        System.out.println(time.getHour());
//        System.out.println(time.getMinute());
//        System.out.println(time.getSecond());
//        System.out.println(time.getNano());
//
//        // using the toSecondOfDay() method
//        System.out.println(time.toSecondOfDay());
//
//        // arithmetic methods of LocalTime(add and subtract hours, minutes, seconds, and nanoseconds
//        LocalTime time1 = time.plusHours(5); // 16:45:30
//        LocalTime time2 = time.plusHours(22); // 09:45:30
//        LocalTime time3 = time.minusMinutes(10); // 11:35:30
//        LocalTime time4 = time.minusSeconds(30); // 11:45
//
//        // return a copy of an instance with one altered part
//        LocalTime time5 = time.withHour(23); // 23:45:30
//        LocalTime time6 = time.withMinute(50); // 11:50:30
//        LocalTime time7 = time.withSecond(0); // 11:45

//        // Some hours and minutes ago
//        Scanner scanner = new Scanner(System.in);
//        String firstPointInTime = scanner.nextLine();
//        int hour = scanner.nextInt();
//        int minute = scanner.nextInt();
//
//        LocalTime timeParser = LocalTime.parse(firstPointInTime);
//        timeParser.minusHours(hour).minusMinutes(minute);
//
//        System.out.println(timeParser);

//        // seconds between two time points
//        Scanner scanner = new Scanner(System.in);
//        String firstTime = scanner.nextLine();
//        String secondTime = scanner.nextLine();
//
//        LocalTime startTime = LocalTime.parse(firstTime);
//        LocalTime endTime = LocalTime.parse(secondTime);
//
//        System.out.println(Math.abs(Duration.between(startTime, endTime).toSeconds()));

//        // seconds since the start of the day
//        Scanner scanner = new Scanner(System.in);
//        long seconds = scanner.nextLong();
//
//        LocalTime midnight = LocalTime.MIDNIGHT;
//
//        System.out.println(midnight.plusSeconds(seconds));

//        // creating LocalDateTime and current time
//        LocalDateTime currentDateTime = LocalDateTime.now();
//        System.out.println("Current time is: " + currentDateTime);
//
//        LocalDateTime dt1 = LocalDateTime.of(2017, 11, 25, 22, 30);  // 25 November 2017, 22:30
//        LocalDateTime dt2 = LocalDateTime.parse("2017-11-25T22:30"); // 25 November 2017, 22:30
//        System.out.println("Dt1 is: " + dt1);
//        System.out.println("Dt2 is: " + dt2);
//
//        // obtaining instances from LocalDate and LocalTime
//        LocalDate date = LocalDate.of(2017, 11, 25); // 2017-11-25
//        LocalTime time = LocalTime.of(21, 30); // 21:30
//
//        LocalDateTime dateTime1 = date.atTime(time); // 2017-11-25T21:30
//        LocalDateTime dateTime2 = time.atDate(date); // 2017-11-25T21:30
//        System.out.println("Date1 is: " + dateTime1);
//        System.out.println("Date2 is: " + dateTime2);
//
//        // LocalDateTime: from years to minutes
//        LocalDateTime dateTime = LocalDateTime.of(2017, 11, 25, 22, 30);
//
//        int month = date.getMonthValue();
//        int day = date.getDayOfMonth();
//        int year = date.getYear();
//        int hour = dateTime.getHour();
//        int minute = dateTime.getMinute();
//
//        // getting date and time from LocalDateTime
//        LocalDate dateOf = dateTime.toLocalDate(); // 2017-11-25
//        LocalTime timeOf = dateTime.toLocalTime(); // 22:30
//
//        // arithmetic methods of LocalDateTime
//        LocalDateTime endOf2017 = LocalDateTime.of(2017, 12, 31, 23, 59, 59); // 2017-12-31T23:59:59
//
//        LocalDateTime beginningOf2018 = endOf2017.plusSeconds(1); // 2018-01-01T00:00
//        LocalDateTime beginningOf2020 = beginningOf2018.plusYears(2); // 2020-01-01T00:00

//        // merging date-time instances
//        final Scanner scanner = new Scanner(System.in);
//        final LocalDateTime firstDateTime = LocalDateTime.parse(scanner.nextLine());
//        final LocalDateTime secondDateTime = LocalDateTime.parse(scanner.nextLine());
//        System.out.println(merge(firstDateTime, secondDateTime));

//        // subtracting hours and adding minutes
//        Scanner scanner = new Scanner(System.in);
//
//        String inputDateTime = scanner.nextLine();
//        LocalDateTime dateTime = LocalDateTime.parse(inputDateTime);
//
//        int hoursToSubtract = scanner.nextInt();
//        int minutesToAdd = scanner.nextInt();
//
//        LocalDateTime result = dateTime
//                .minusHours(hoursToSubtract)
//                .plusMinutes(minutesToAdd);
//
//        // Print a result in the same format
//        System.out.println(result);

//        // add 11 hours and print the date
//        Scanner scanner = new Scanner(System.in);
//
//        String inputDateTime = scanner.nextLine();
//        LocalDateTime dateTime = LocalDateTime.parse(inputDateTime);
//
//        LocalDateTime result = dateTime.plusHours(11);
//
//        System.out.println(result.toLocalDate());

//        // the passed hours since the beginning of the year
//        Scanner scanner = new Scanner(System.in);
//
//        String inputDateTime = scanner.nextLine();
//        LocalDateTime dateTime = LocalDateTime.parse(inputDateTime);
//
//        LocalDateTime startOfYear = LocalDateTime.of(dateTime.getYear(), 1, 1, 0, 0);
//        long hoursPassed = Duration.between(startOfYear, dateTime).toHours();
//
//        System.out.println(hoursPassed);

//        System.out.println(LocalDateTime.of(LocalDate.of(2020, 1, 1), LocalTime.MIDNIGHT).minusSeconds(1));
//        System.out.println(LocalDate.parse("2017-01-01").withMonth(11).withDayOfMonth(11));

//        // boxing and unboxing
//        int primitive = 100;
//        Integer reference = Integer.valueOf(primitive); // boxing
//        int anotherPrimitive = reference.intValue();    // unboxing
//
//        // NPE when unboxing null value
//        Long val = null;
//        long unboxed = val != null ? val : 0;
//
//        // NPE may be caused since auto-unboxing is involved
//        Integer n1 = 50;
//        Integer n2 = null;
//        Integer result = n1 / n2; // It throws an NPE
//
//        // null reference
//        Long longReference = null;
//        long longValue = longReference;
//        System.out.println(longValue);

//        // month of year using strings
//        Scanner scanner = new Scanner(System.in);
//        int monthValue = scanner.nextInt();
//        String month = getMonth(monthValue);
//        System.out.println(month);

//        // creating objects of generic classes
//        GenericType<Integer> obj1 = new GenericType<>(10);
//        GenericType<String> obj2 = new GenericType<>("abc");
//
//        var obj3 = new GenericType<>("abc");
//
//        Integer number = obj1.get();
//        String string = obj2.get();
//
//        System.out.println(obj1.set(20));
//        System.out.println(obj2.set("def"));
//
//        System.out.println(number);
//        System.out.println(string);
//
//        // creating a custom generic array
//        var stringArray = new ImmutableArray<>(new String[]{"item1", "item2", "item3"});
//
//        for (int i=0; i< stringArray.length(); i++) {
//            System.out.println(stringArray.get(i) + " ");
//        }
//
//        var doubleArray = new ImmutableArray<>(new Double[]{1.03, 2.04});
//        for(int i = 0; i < doubleArray.length(); i++){
//            System.out.println(doubleArray.get(i));
//        }

//        // reusing code with Object
//        NonGenericClass instance2 = new NonGenericClass("abc");
//
//        String str = (String) instance2.get();
//        System.out.println(str);
//
//        NonGenericClass instance3 = new NonGenericClass(123);
//        Integer int2 = (Integer) instance3.get();
//        System.out.println(int2);
//
//        GenericType<String> instance4 = new GenericType<>("abc");
//
//        String str4 = instance4.get();
//        System.out.println(str4);
//
//        GenericType instance5 = new GenericType("my-string");
//        GenericType<Object> instance6 = new GenericType<>("my-string");
//        System.out.println(instance5);
//        System.out.println(instance6);

//        MyClass instance = new MyClass("Hello!");
//        System.out.println(instance.getT());


        EnumSet<Direction> enumSet = EnumSet.allOf(Direction.class);
        for (Direction direction : enumSet) {
            System.out.println(direction.getShortCode());
        }

    }
}


